##############################################################################
# 1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора 
# класса (метод __init__()), который должен принимать данные (список списков) 
# для формирования матрицы.
# Подсказка: матрица — система некоторых математических величин, расположенных 
# в виде прямоугольной схемы.
# Примеры матриц: 3 на 2, 3 на 3, 2 на 4.
#
# 31    32         3    5    32        3    5    8    3
# 37    43         2    4    6         8    3    7    1
# 51    86        -1   64   -8
# Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы 
# в привычном виде.
# Далее реализовать перегрузку метода __add__() для реализации операции 
# сложения двух объектов класса Matrix (двух матриц). Результатом сложения 
# должна быть новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент 
# первой строки первой матрицы складываем с первым элементом первой строки
# второй матрицы и т.д.

class Matrix:
    def __init__(self, my_lst):
        self.my_lst=my_lst
    
    def __str__(self):
        return '\n'.join(map(str, self.my_lst))    
    
    def __add__(self, other):
        for i in range(len(self.my_lst)):
            for j in range(len(other.my_lst[i])):
                self.my_lst[i][j] = self.my_lst[i][j] + other.my_lst[i][j]
        return Matrix.__str__(self)
      
my_matrix = Matrix([[1, 2, 3],
                    [1, 2, 3],
                    [1, 2, 3]])

my_matrix2 = Matrix([[3, 2, 1],
                    [3, 2, 1],
                    [3, 2, 1]])

print(my_matrix.__add__(my_matrix2))

##############################################################################
# 2. Реализовать проект расчёта суммарного расхода ткани на производство одежды. 
# Основная сущность (класс) этого проекта — одежда, которая может иметь 
# определённое название. К типам одежды в этом проекте относятся пальто и костюм. 
# У этих типов одежды существуют параметры: размер (для ) и рост (для костюма). 
# Это могут быть обычные числа: V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы: 
    # для пальто (V/6.5 + 0.5), для костюма (2*H + 0.3). 
    # Проверить работу этих методов на реальных данных.пальто
# Реализовать общий подсчет расхода ткани. Проверить на практике полученные 
# на этом уроке знания: реализовать абстрактные классы для основных классов проекта, 
# проверить на практике работу декоратора @property.

class Clothes:
    def __init__(self, size, height):
        self.size=size
        self.height=height
    
   
    def coat_size(self):
        return round((self.size/6.5+0.5),2)
    
     
    def suit_size(self):
        return 2*self.height+0.3

    @property
    def full_size(self):
        return str(f'Общий расход ткани {round(((self.size/6.5+0.5)+(2*self.height+0.3)),2)}')

class Coat(Clothes):
    def __init__(self, size, height):
        super().__init__(size, height)
        self.square_c = round((self.size / 6.5 + 0.5),2)
        
    def __str__(self):
        return (f'Для пошива пальто нужно: {self.square_c} ткани')
    
class Suit(Clothes):
    def __init__(self, size, height):
        super().__init__(size, height)
        self.square_s = 2*self.height + 0.3
    def __str__(self):
        return (f'Для пошива костюма нужно: {self.square_s} ткани')

c = Coat(2,3)
s = Suit(4,5)

print(c)
print(s)
print(c.full_size)
print(s.full_size)
print(s.coat_size())
print(s.suit_size())


##############################################################################
#3. Реализовать программу работы с органическими клетками, состоящими из ячеек. 
# Необходимо создать класс Клетка. В его конструкторе инициализировать параметр, 
# соответствующий количеству ячеек клетки (целое число). В классе должны быть 
# реализованы методы перегрузки арифметических операторов: сложение (__add__()),
# вычитание (__sub__()), умножение (__mul__()), деление (__truediv__()). 
# Данные методы должны применяться только к клеткам и выполнять увеличение, 
# уменьшение, умножение и целочисленное (с округлением до целого) деление клеток, 
# соответственно.
#
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно 
# равняться сумме ячеек исходных двух клеток.
#
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если 
# разность количества ячеек двух клеток больше нуля, иначе выводить 
# соответствующее сообщение.
#
# Умножение. Создаётся общая клетка из двух. Число ячеек общей клетки 
# определяется как произведение количества ячеек этих двух клеток.
#
# Деление. Создаётся общая клетка из двух. Число ячеек общей клетки определяется 
# как целочисленное деление количества ячеек этих двух клеток.

# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса 
# и количество ячеек в ряду. Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество 
# ячеек между \n равно переданному аргументу. Если ячеек на формирование ряда 
# не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. 
# Тогда метод make_order() вернёт строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. 
# Тогда метод make_order() вернёт строку: *****\n*****\n*****.
# Подсказка: подробный список операторов для перегрузки доступен по ссылке.

class Cell:
    def __init__(self, count_cell:int):
        self.count_cell=count_cell
        
    def __add__(self, other):
        return f'Объединение двух клеток. Размер клетки равен: {self.count_cell + other.count_cell} ячеек'

    def __sub__(self, other):
        sub=self.count_cell-other.count_cell
        return f'Уменьшение клетки до {sub} ячеек' if sub > 0 else 'Отрицательный результат вычитания'

    def __mul__(self, other:int):
        return f'Умножение двух клеток. Размер клетки равен: {self.count_cell * other.count_cell} ячеек'

    def __truediv__(self, other):
         return f'Деление двух клеток. Размер клетки равен: {self.count_cell // other.count_cell} ячеек'

    def make_order(self, cell_row:int):
        row=''
        for i in range(int(self.count_cell / cell_row)):
            row += '*' * cell_row + '\n'
        row += '*' * (self.count_cell % cell_row) + '\n'
        return row


c = Cell(24)
c2 = Cell(3) 
print(c + c2)
print(c - c2)
print(c / c2)
print(c * c2)
print(c.make_order(7))



